<!DOCTYPE html>
<html>
<head>
    <title>三体模拟器 - 高速版</title>
    <style>
        canvas { border: 1px solid #000; background: #000; }
        .control-panel { margin: 10px; padding: 10px; border: 1px solid #444; background: #333; color: #fff; }
        .param-group { margin: 5px; padding: 5px; border-bottom: 1px dashed #666; }
        input[type="number"] { width: 60px; background: #222; color: #fff; border: 1px solid #444; }
        button { background: #444; color: #fff; border: 1px solid #666; padding: 5px 10px; }
    </style>
</head>
<body>
    <div class="control-panel">
        <div>
            <button onclick="toggleMode()">切换2D/3D</button>
            模式: <span id="modeDisplay">3D</span>
            <button id="startBtn" onclick="toggleRunning()">启动引擎</button>
            <button onclick="hyperJump()">量子跳跃</button>
        </div>
        
        <div class="param-group">
            天体数量: 
            <select id="bodyCount" onchange="handleBodyCountChange()">
                <option>1</option>
                <option>2</option>
                <option selected>3</option>
                <option>4</option>
                <option>5</option>
            </select>
            时间流速: 
            <input type="range" id="timeStep" min="0.001" max="0.5" step="0.001" value="0.05" 
                   oninput="updateTimeStep(this.value)">
            <span id="timeStepValue">0.05</span>
        </div>

        <div id="parameters"></div>
    </div>

    <canvas id="canvas" width="1200" height="800"></canvas>

    <script>
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        let is3D = true;
        let bodies = [];
        let running = false;
        let trail = [];
        const G = 8000; // 增强引力常数
        let animationFrameId = null;
        let velocityScale = 2.5; // 速度显示倍率

        class CosmicBody {
            constructor(mass, x, y, z, vx, vy, vz, color) {
                this.mass = Math.max(1, mass) * 1e4; // 质量放大
                this.position = {x, y, z};
                this.velocity = {
                    x: vx * velocityScale,
                    y: vy * velocityScale, 
                    z: vz * velocityScale
                };
                this.color = color || this.generateQuantumColor();
            }

            generateQuantumColor() {
                return `hsl(${Math.random()*360}, 70%, 60%)`;
            }
        }

        function initializeExample() {
            bodies = [
                new CosmicBody(1.8, 500, 400, 0, 0, -8, 0),
                new CosmicBody(2.4, 700, 400, 0, 0, 6, 0),
                new CosmicBody(1.2, 600, 600, 0, 5, 0, 0)
            ];
        }

        function calculateRelativisticForces() {
            const dt = parseFloat(document.getElementById('timeStep').value);
            
            bodies.forEach((body, i) => {
                let ax = 0, ay = 0, az = 0;
                
                bodies.forEach((other, j) => {
                    if (i === j) return;
                    
                    const dx = other.position.x - body.position.x;
                    const dy = other.position.y - body.position.y;
                    const dz = other.position.z - body.position.z;
                    
                    // 相对论修正的距离计算
                    const rSquared = dx*dx + dy*dy + dz*dz + 1000; // 软化长度
                    const invR3 = 1 / (rSquared * Math.sqrt(rSquared));
                    
                    ax += G * other.mass * dx * invR3;
                    ay += G * other.mass * dy * invR3;
                    az += G * other.mass * dz * invR3;
                });

                // 洛伦兹因子γ（简化版）
                const vSq = body.velocity.x&zwnj;**2 + body.velocity.y**&zwnj;2;
                const gamma = vSq > 1e5 ? 0.1 : 1 / Math.sqrt(1 - vSq/1e6);
                
                // 更新速度
                body.velocity.x += ax * dt * gamma;
                body.velocity.y += ay * dt * gamma;
                body.velocity.z += az * dt * gamma;
            });

            // 更新位置（考虑速度缩放）
            bodies.forEach(body => {
                body.position.x += body.velocity.x * dt * velocityScale;
                body.position.y += body.velocity.y * dt * velocityScale;
                body.position.z += body.velocity.z * dt * velocityScale;
            });
        }

        function drawWarpspeed() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 绘制相对论蓝移/红移效果
            bodies.forEach((body, i) => {
                const speed = Math.sqrt(
                    body.velocity.x**2 + 
                    body.velocity.y**2
                );
                
                // 多普勒效应颜色偏移
                const hueShift = speed * 0.5;
                const shiftedColor = `hsl(${(parseInt(body.color.slice(4,7)) + hueShift) % 360}, 70%, 60%)`;

                // 速度线
                ctx.beginPath();
                ctx.moveTo(body.position.x, body.position.y);
                ctx.lineTo(
                    body.position.x - body.velocity.x * 2,
                    body.position.y - body.velocity.y * 2
                );
                ctx.strokeStyle = shiftedColor;
                ctx.lineWidth = Math.log10(speed + 1);
                ctx.stroke();

                // 引力透镜效果
                ctx.beginPath();
                ctx.arc(body.position.x, body.position.y, Math.sqrt(body.mass)/20, 0, Math.PI*2);
                const gradient = ctx.createRadialGradient(
                    body.position.x, body.position.y, 0,
                    body.position.x, body.position.y, Math.sqrt(body.mass)/5
                );
                gradient.addColorStop(0, shiftedColor);
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = gradient;
                ctx.fill();
            });

            // 绘制量子轨迹
            trail.push(bodies.map(b => ({...b.position})));
            if (trail.length > 50) trail.shift();
            
            trail.forEach((positions, index) => {
                positions.forEach((pos, i) => {
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 3 * (index/50), 0, Math.PI*2);
                    ctx.fillStyle = `${bodies[i].color}${Math.round(80 - index*1.6).toString(16).padStart(2, '0')}`;
                    ctx.fill();
                });
            });
        }

        function hyperJump() {
            bodies.forEach(body => {
                body.velocity.x *= 3;
                body.velocity.y *= 3;
                body.velocity.z *= 3;
            });
            velocityScale *= 1.5;
        }

        function updateTimeStep(value) {
            document.getElementById('timeStepValue').textContent = value;
        }

        // 其他辅助函数保持类似结构，调整参数更新逻辑...
        // 初始化、控制逻辑等与之前版本类似，主要调整参数范围

        initializeExample();
        // ...其余界面控制代码...
    </script>
</body>
</html>